
from enum import IntEnum
import numpy as np
from options import CURVE_FRAMES, CURVE_RESOLUTION
from fnode import FNode

T = FNode.Type

CALC_FUNCTIONS = {
    T.PI: lambda *_: np.pi,
    T.E: lambda *_: np.e,
    T.W: lambda *_: np.tile(np.linspace(0, 1, CURVE_RESOLUTION), (CURVE_FRAMES, 1)),
    T.X: lambda *_: np.tile(np.linspace(-1, 1, CURVE_RESOLUTION), (CURVE_FRAMES, 1)),
    T.Y: lambda *_: np.repeat(np.linspace(-1, 1, CURVE_FRAMES), CURVE_RESOLUTION).reshape(CURVE_FRAMES, CURVE_RESOLUTION),
    T.Z: lambda *_: np.repeat(np.linspace(0, 1, CURVE_FRAMES), CURVE_RESOLUTION).reshape(CURVE_FRAMES, CURVE_RESOLUTION),
    T.SIN: np.sin,
    T.COS: np.cos,
    T.TAN: np.tan,
    T.ASIN: np.arcsin,
    T.ACOS: np.arccos,
    T.ATAN: np.arctan,
    T.SINH: np.sinh,
    T.COSH: np.cosh,
    T.TANH: np.tanh,
    T.ASINH: np.arcsinh,
    T.ACOSH: np.arccosh,
    T.ATANH: np.arctanh,
    T.LOG2: np.log2,
    T.LOG10: np.log10,
    T.LN: np.log,
    T.SQRT: np.sqrt,
    T.SIGN: np.sign,
    T.RINT: np.rint,
    T.ABS: np.abs,
    T.NEGATE: np.negative,
    T.ADD: lambda *c: accumulate(np.add, c),
    T.SUBTRACT: lambda *c: accumulate(np.subtract, c),
    T.MULTIPLY: lambda *c: accumulate(np.multiply, c),
    T.DIVIDE: lambda *c: accumulate(np.divide, c),
    T.EXPONENT: lambda *c: accumulate(np.power, c),
    T.EQUAL: lambda *c: accumulate(lambda x, y: np.equal(x, y).astype(int), c),
    T.NOT_EQUAL: lambda *c: 106,
    T.LESS_THAN: lambda *c: 107,
    T.LESS_EQ: lambda *c: 108,
    T.GREATER_THAN: lambda *c: 109,
    T.GREATER_EQ: lambda *c: 110,
    T.OR: lambda *c: 111,
    T.AND: lambda *c: 112,
    T.MIN: lambda *c: 113,
    T.MAX: lambda *c: 114,
    T.SUM: lambda *c: 115,
    T.AVG: lambda *c: 116
}


FORMULA_FUNCTIONS = {
    T.PI: lambda *_: 'pi',
    T.E: lambda *_: 'e',
    T.W: lambda *_: 'w',
    T.X: lambda *_: 'x',
    T.Y: lambda *_: 'y',
    T.Z: lambda *_: 'z',
    T.SIN: lambda *c: f'sin({c[0]})',
    T.COS: lambda *c: f'cos({c[0]})',
    T.TAN: lambda *c: f'tan({c[0]})',
    T.ASIN: lambda *c: f'asin({c[0]})',
    T.ACOS: lambda *c: f'acos({c[0]})',
    T.ATAN: lambda *c: f'atan({c[0]})',
    T.SINH: lambda *c: f'sinh({c[0]})',
    T.COSH: lambda *c: f'cosh({c[0]})',
    T.TANH: lambda *c: f'tanh({c[0]})',
    T.ASINH: lambda *c: f'asinh({c[0]})',
    T.ACOSH: lambda *c: f'acosh({c[0]})',
    T.ATANH: lambda *c: f'atanh({c[0]})',
    T.LOG2: lambda *c: f'log2({c[0]})',
    T.LOG10: lambda *c: f'log10({c[0]})',
    T.LN: lambda *c: f'ln({c[0]})',
    T.SQRT: lambda *c: f'sqrt({c[0]})',
    T.SIGN: lambda *c: f'sign({c[0]})',
    T.RINT: lambda *c: f'rint({c[0]})',
    T.ABS: lambda *c: f'abs({c[0]})',
    T.NEGATE: lambda *c: f'-{c[0]}',
    T.ADD: lambda *c: '+'.join(c),
    T.SUBTRACT: lambda *c: '-'.join(c),
    T.MULTIPLY: lambda *c: '*'.join(c),
    T.DIVIDE: lambda *c: '/'.join(c),
    T.EXPONENT: lambda *c: '^'.join(c),
    T.EQUAL: lambda *c: '=='.join(c),
    T.NOT_EQUAL: lambda *c: '!='.join(c),
    T.LESS_THAN: lambda *c: '<'.join(c),
    T.LESS_EQ: lambda *c: '<='.join(c),
    T.GREATER_THAN: lambda *c: '>'.join(c),
    T.GREATER_EQ: lambda *c: '>='.join(c),
    T.OR: lambda *c: '||'.join(c),
    T.AND: lambda *c: '&&'.join(c),
    T.MIN: lambda *c: 'min(' + ','.join(c) + ')',
    T.MAX: lambda *c: 'max(' + ','.join(c) + ')',
    T.SUM: lambda *c: 'sum(' + ','.join(c) + ')',
    T.AVG: lambda *c: 'avg(' + ','.join(c) + ')',
}

FORMULA_TOKENS = {
    '||': T.OR,
    'z': T.Z,
    'y': T.Y,
    'x': T.X,
    'w': T.W,
    'tanh': T.TANH,
    'tan': T.TAN,
    'sum': T.SUM,
    'sqrt': T.SQRT,
    'sinh': T.SINH,
    'sin': T.SIN,
    'sign': T.SIGN,
    'rint': T.RINT,
    'pi': T.PI,
    'min': T.MIN,
    'max': T.MAX,
    'log2': T.LOG2,
    'log10': T.LOG10,
    'ln': T.LN,
    'e': T.E,
    'cosh': T.COSH,
    'cos': T.COS,
    'avg': T.AVG,
    'atanh': T.ATANH,
    'atan': T.ATAN,
    'asinh': T.ASINH,
    'asin': T.ASIN,
    'acosh': T.ACOSH,
    'acos': T.ACOS,
    'abs': T.ABS,
    '^': T.EXPONENT,
    '>=': T.GREATER_EQ,
    '>': T.GREATER_THAN,
    '==': T.EQUAL,
    '<=': T.LESS_EQ,
    '<': T.LESS_THAN,
    '/': T.DIVIDE,
    '-': T.SUBTRACT,
    '+': T.ADD,
    '*': T.MULTIPLY,
    ')': T.CLOSE_PAREN,
    '(': T.OPEN_PAREN,
    '&&': T.AND,
    '!=': T.NOT_EQUAL
}


DISPLAY_NAMES = {
    T.CONSTANT: 'constant value',
    T.PI: 'pi',
    T.E: 'e',
    T.W: 'w',
    T.X: 'x',
    T.Y: 'y',
    T.Z: 'z',
    T.SIN: 'sin',
    T.COS: 'cos',
    T.TAN: 'tan',
    T.ASIN: 'arcsin',
    T.ACOS: 'arccos',
    T.ATAN: 'arctan',
    T.SINH: 'sinh',
    T.COSH: 'cosh',
    T.TANH: 'tanh',
    T.ASINH: 'asinh',
    T.ACOSH: 'acosh',
    T.ATANH: 'atanh',
    T.LOG2: 'log (base 2)',
    T.LOG10: 'log (base 10)',
    T.LN: 'log (base e)',
    T.SQRT: 'square root',
    T.SIGN: 'sign',
    T.RINT: 'round',
    T.ABS: 'absolute value',
    T.NEGATE: 'negate',
    T.ADD: 'plus',
    T.SUBTRACT: 'minus',
    T.MULTIPLY: 'multiply',
    T.DIVIDE: 'divide',
    T.EXPONENT: 'exponent',
    T.EQUAL: 'equals',
    T.NOT_EQUAL: 'not equals',
    T.LESS_THAN: 'less than',
    T.LESS_EQ: 'less or eq.',
    T.GREATER_THAN: 'greater than',
    T.GREATER_EQ: 'greater or eq.',
    T.OR: 'or',
    T.AND: 'and',
    T.MIN: 'minimum',
    T.MAX: 'maximum',
    T.SUM: 'sum',
    T.AVG: 'average'
}


def accumulate(_, fn, params):
    if(not params):
        return 0
    s = params[0]
    for i in range(1, len(params)):
        s = fn(s, params[i])
    return s